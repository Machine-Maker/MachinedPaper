From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Wed, 8 Dec 2021 16:49:33 -0800
Subject: [PATCH] Property API


diff --git a/src/main/java/io/papermc/paper/world/data/BooleanProperty.java b/src/main/java/io/papermc/paper/world/data/BooleanProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec47a3f848e626f176b7d4e5832990a918c88bf2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/BooleanProperty.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.world.data;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Set;
+
+public final class BooleanProperty extends Property<Boolean> {
+
+    private static final Set<Boolean> VALUES = Set.of(true, false);
+
+    BooleanProperty(String name) {
+        super(name, Boolean.class);
+    }
+
+    @Override
+    public @NotNull String name(@NotNull Boolean value) {
+        return value.toString();
+    }
+
+    @Override
+    public boolean isValidName(@NotNull String name) {
+        return name.equals("true") || name.equals("false");
+    }
+
+    @Override
+    public @NotNull Boolean value(@NotNull String name) {
+        return switch (name) {
+            case "true" -> true;
+            case "false" -> false;
+            default -> throw EXCEPTION_CREATOR.create(name, ExceptionCreator.Type.NAME, this);
+        };
+    }
+
+    @Override
+    public boolean isValue(@NotNull Object object) {
+        return object instanceof Boolean;
+    }
+
+    @Override
+    public @NotNull Collection<Boolean> values() {
+        return VALUES;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/world/data/EnumProperty.java b/src/main/java/io/papermc/paper/world/data/EnumProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..7045af4df184e1c7e65dad1b2c5c524278e08095
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/EnumProperty.java
@@ -0,0 +1,114 @@
+package io.papermc.paper.world.data;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.Sets;
+import net.kyori.adventure.util.Index;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.ToIntFunction;
+
+public sealed class EnumProperty<E extends Enum<E>> extends Property<E> permits EnumProperty.EnumIntRepresented {
+
+    private final Set<E> values;
+    private @Nullable Index<String, E> byName; // needs lazy init due to static circular dependencies
+
+    EnumProperty(String name, Class<E> type, Collection<E> values) {
+        super(name, type);
+        this.values = Sets.immutableEnumSet(values);
+    }
+
+    private @NotNull Index<String, E> byNameIndex() {
+        if (this.byName == null) {
+            this.byName = this.createByNameIndex();
+        }
+        return this.byName;
+    }
+
+    protected @NotNull Index<String, E> createByNameIndex() {
+        return Index.create(e -> Bukkit.getUnsafe().getPropertyEnumName(this, e), List.copyOf(this.values));
+    }
+
+    @Override
+    public @NotNull String name(@NotNull E value) {
+        final String valueName = this.byNameIndex().key(value);
+        if (valueName == null) {
+            throw EXCEPTION_CREATOR.create(value, ExceptionCreator.Type.VALUE, this);
+        }
+        return valueName;
+    }
+
+    @Override
+    public boolean isValidName(@NotNull String name) {
+        return this.byNameIndex().value(name) != null;
+    }
+
+    @Override
+    public @NotNull E value(@NotNull String name) {
+        final E value = this.byNameIndex().value(name);
+        if (value == null) {
+            throw EXCEPTION_CREATOR.create(name, ExceptionCreator.Type.NAME, this);
+        }
+        return value;
+    }
+
+    @Override
+    public boolean isValue(@NotNull Object object) {
+        return this.type().isInstance(object) && this.values.contains(object);
+    }
+
+    @Override
+    public @NotNull Collection<E> values() {
+        return this.values;
+    }
+
+    /**
+     * Represents a property whose value is stored as an int,
+     * but represented as an enum
+     * @param <E> enum type
+     */
+    public sealed static class EnumIntRepresented<E extends Enum<E>> extends EnumProperty<E> implements IntegerProperty.IntRepresented<E> permits RotationProperty {
+
+        private final BiMap<E, Integer> cache;
+
+        EnumIntRepresented(String name, Class<E> type, Collection<E> values) {
+            this(name, type, values, E::ordinal);
+        }
+
+        EnumIntRepresented(String name, Class<E> type, Collection<E> values, ToIntFunction<E> toIntFunction) {
+            super(name, type, values);
+            this.cache = HashBiMap.create(values.size());
+            for (E value : this.values()) {
+                this.cache.put(value, toIntFunction.applyAsInt(value));
+            }
+        }
+
+        @Override
+        protected @NotNull Index<String, E> createByNameIndex() {
+            return Index.create(v -> Integer.toString(this.toIntValue(v)), List.copyOf(this.cache.keySet()));
+        }
+
+        @Override
+        public int toIntValue(@NotNull E value) {
+            if (!this.cache.containsKey(value)) {
+                throw EXCEPTION_CREATOR.create(value, ExceptionCreator.Type.VALUE, this);
+            }
+            return this.cache.get(value);
+        }
+
+        @Override
+        public @NotNull E fromIntValue(int value) {
+            if (!this.cache.inverse().containsKey(value)) {
+                throw EXCEPTION_CREATOR.create(value, ExceptionCreator.Type.VALUE, this);
+            }
+            return this.cache.inverse().get(value);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/world/data/IntegerProperty.java b/src/main/java/io/papermc/paper/world/data/IntegerProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..1edf044ff62e9e2af858455bc0b43adf6f8f418a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/IntegerProperty.java
@@ -0,0 +1,123 @@
+package io.papermc.paper.world.data;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+public final class IntegerProperty extends Property<Integer> {
+
+    private final Set<Integer> values;
+    private final int min;
+    private final int max;
+
+    IntegerProperty(String name, int min, int max) {
+        super(name, Integer.class);
+        this.min = min;
+        this.max = max;
+        if (min < 0 || max <= min) {
+            throw new IllegalArgumentException("Invalid range. Min: " + min + ", Max: " + max);
+        }
+        Set<Integer> set = new LinkedHashSet<>();
+        for (int i = min; i <= max; i++) {
+            set.add(i);
+        }
+        this.values = Collections.unmodifiableSet(set); // use unmodifiable to preserve order (but in reality its immutable)
+    }
+
+    /**
+     * Gets the min value for this property.
+     *
+     * @return the min value
+     */
+    public int min() {
+        return this.min;
+    }
+
+    /**
+     * Gets the max value for this property.
+     *
+     * @return the max value
+     */
+    public int max() {
+        return this.max;
+    }
+
+    @Override
+    public @NotNull String name(@NotNull Integer value) {
+        if (value > this.max || value < this.min) {
+            throw EXCEPTION_CREATOR.create(value, ExceptionCreator.Type.VALUE, this);
+        }
+        return value.toString();
+    }
+
+    @Override
+    public boolean isValidName(@NotNull String name) {
+        try {
+            Integer value = Integer.valueOf(name);
+            if (this.values.contains(value)) {
+                return true;
+            }
+        } catch (NumberFormatException ignored) {
+        }
+        return false;
+    }
+
+    @Override
+    public @NotNull Integer value(@NotNull String name) {
+        try {
+            Integer value = Integer.valueOf(name);
+            if (this.values.contains(value)) {
+                return value;
+            }
+            throw EXCEPTION_CREATOR.create(name, ExceptionCreator.Type.NAME, this);
+        } catch (NumberFormatException exception) {
+            throw EXCEPTION_CREATOR.create(name, ExceptionCreator.Type.NAME, this);
+        }
+    }
+
+    @Override
+    public boolean isValue(@NotNull Object object) {
+        return object instanceof Integer num && num >= this.min && num <= this.max;
+    }
+
+    @Override
+    public @NotNull Collection<Integer> values() {
+        return this.values;
+    }
+
+    /**
+     * Represents properties that are represented in the API as non-integers
+     * but stored as integers
+     *
+     * @param <T> type
+     */
+    public sealed interface IntRepresented<T> permits EnumProperty.EnumIntRepresented, NoteProperty {
+
+        /**
+         * Convert the value to its integer representation.
+         *
+         * @param value the value to convert
+         * @return the integer representation
+         */
+        int toIntValue(@NotNull T value);
+
+        /**
+         * Convert the int representation into its
+         * API value.
+         *
+         * @param value the integer representation
+         * @return the API value
+         */
+        @NotNull T fromIntValue(int value);
+
+        /**
+         * Gets the API type.
+         *
+         * @return the API type
+         */
+        @NotNull Class<T> type();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/world/data/NoteProperty.java b/src/main/java/io/papermc/paper/world/data/NoteProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..2caba86f75b5471206f6aa40ee5723a1c37199d4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/NoteProperty.java
@@ -0,0 +1,72 @@
+package io.papermc.paper.world.data;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import org.bukkit.Note;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public final class NoteProperty extends Property<Note> implements IntegerProperty.IntRepresented<Note> {
+
+    private final BiMap<Integer, Note> cache;
+
+    public NoteProperty(@NotNull String name) {
+        super(name, Note.class);
+        this.cache = HashBiMap.create(24);
+        for (int i = 0; i <= 24; i++) {
+            this.cache.put(i, new Note(i));
+        }
+    }
+
+    @Override
+    public @NotNull String name(@NotNull Note value) {
+        return String.valueOf(value.getId());
+    }
+
+    @Override
+    public boolean isValidName(@NotNull String name) {
+        try {
+            Integer value = Integer.valueOf(name);
+            if (this.cache.containsKey(value)) {
+                return true;
+            }
+        } catch (NumberFormatException ignored) {
+        }
+        return false;
+    }
+
+    @Override
+    public @NotNull Note value(@NotNull String name) {
+        try {
+            Integer value = Integer.valueOf(name);
+            if (this.cache.containsKey(value)) {
+                return this.cache.get(value);
+            }
+            throw EXCEPTION_CREATOR.create(name, ExceptionCreator.Type.NAME, this);
+        } catch (NumberFormatException exception) {
+            throw EXCEPTION_CREATOR.create(name, ExceptionCreator.Type.NAME, this);
+        }
+    }
+
+    @Override
+    public boolean isValue(@NotNull Object object) {
+        return object instanceof Note note && this.cache.inverse().containsKey(note);
+    }
+
+    @Override
+    public @NotNull Collection<@NotNull Note> values() {
+        return Collections.unmodifiableSet(this.cache.values());
+    }
+
+    @Override
+    public int toIntValue(@NotNull Note value) {
+        return value.getId();
+    }
+
+    @Override
+    public @NotNull Note fromIntValue(int value) {
+        return this.cache.get(value);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/world/data/PropertiesHolder.java b/src/main/java/io/papermc/paper/world/data/PropertiesHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..5685828141fe6fdff0e52f34cd74163f94940842
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/PropertiesHolder.java
@@ -0,0 +1,88 @@
+package io.papermc.paper.world.data;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Optional;
+
+/**
+ * Represents an object that holds {@link Property}s.
+ */
+public interface PropertiesHolder {
+
+    /**
+     * Gets the property with this name on the holder (if it exists)
+     *
+     * @param propertyName name of the property
+     * @param <T> property type;
+     * @return the property, if one is found with that name
+     */
+    <T extends Comparable<T>> @Nullable Property<T> getProperty(@NotNull String propertyName);
+
+    /**
+     * Checks if this has the property.
+     *
+     * @param property the property to check for
+     * @param <T> property type
+     * @return true if property is present
+     * @see Property#hasValueOn(PropertiesHolder)
+     */
+    <T extends Comparable<T>> boolean hasProperty(@NotNull Property<T> property);
+
+    /**
+     * Gets the value for the specified property
+     *
+     * @param property the property
+     * @param <T> property type
+     * @return the non-null value
+     * @throws IllegalArgumentException if the property is not present
+     * @see #hasProperty(Property)
+     * @see Property#getValue(PropertiesHolder)
+     */
+    <T extends Comparable<T>> @NotNull T getValue(@NotNull Property<T> property);
+
+    /**
+     * Gets the optional of the value for the specified property.
+     *
+     * @param property the property
+     * @param <T> property type
+     * @return the optional of the value, will be empty if the property is not present
+     * @see #getValue(Property)
+     * @see Property#getOptionalValue(PropertiesHolder)
+     */
+    <T extends Comparable<T>> @NotNull Optional<T> getOptionalValue(@NotNull Property<T> property);
+
+    /**
+     * Sets the value of the specified property.
+     *
+     * @param property the property
+     * @param value the value for the property
+     * @param <T> property type
+     * @throws IllegalArgumentException if the property is not present or if the value is invalid
+     * @see #hasProperty(Property)
+     * @see Property#setValue(PropertiesHolder, Comparable)
+     */
+    <T extends Comparable<T>> void setValue(@NotNull Property<T> property, @NotNull T value);
+
+    /**
+     * Sets the value of the specified property.
+     *
+     * @param property the property
+     * @param value the value for the property
+     * @param <T> property type
+     * @throws IllegalArgumentException if the property is not present or if the value is invalid
+     * @see #hasProperty(Property)
+     * @see Property#setValue(PropertiesHolder, Comparable)
+     */
+    default <T extends Comparable<T>> void setValue(@NotNull Property<T> property, @NotNull Object value) {
+        property.setValue(this, value);
+    }
+
+    /**
+     * Get all properties present on this.
+     *
+     * @return an unmodifiable collection of properties
+     */
+    @NotNull Collection<Property<?>> getProperties();
+}
diff --git a/src/main/java/io/papermc/paper/world/data/Property.java b/src/main/java/io/papermc/paper/world/data/Property.java
new file mode 100644
index 0000000000000000000000000000000000000000..d52fec54e5a72efebe462e0ffd38dee3adb6495c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/Property.java
@@ -0,0 +1,332 @@
+package io.papermc.paper.world.data;
+
+import com.google.common.base.MoreObjects;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimap;
+import org.bukkit.Axis;
+import org.bukkit.Instrument;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.data.Bisected;
+import org.bukkit.block.data.FaceAttachable;
+import org.bukkit.block.data.Rail;
+import org.bukkit.block.data.type.Bamboo;
+import org.bukkit.block.data.type.Bed;
+import org.bukkit.block.data.type.Bell;
+import org.bukkit.block.data.type.BigDripleaf;
+import org.bukkit.block.data.type.Chest;
+import org.bukkit.block.data.type.Comparator;
+import org.bukkit.block.data.type.Door;
+import org.bukkit.block.data.type.Jigsaw;
+import org.bukkit.block.data.type.PointedDripstone;
+import org.bukkit.block.data.type.RedstoneWire;
+import org.bukkit.block.data.type.SculkSensor;
+import org.bukkit.block.data.type.Slab;
+import org.bukkit.block.data.type.Stairs;
+import org.bukkit.block.data.type.StructureBlock;
+import org.bukkit.block.data.type.TechnicalPiston;
+import org.bukkit.block.data.type.Wall;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Locale;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
+@SuppressWarnings("StaticInitializerReferencesSubClass")
+public abstract sealed class Property<T extends Comparable<T>> permits BooleanProperty, IntegerProperty, EnumProperty, NoteProperty {
+
+    protected static final ExceptionCreator EXCEPTION_CREATOR = (value, type, property) -> new IllegalArgumentException(String.format("%s (%s) is not a valid %s for %s",value, value.getClass().getSimpleName(), type.name().toLowerCase(Locale.ENGLISH), property));
+
+    private static final ImmutableSetMultimap.Builder<String, Property<?>> PROPERTY_MULTIMAP_BUILDER = ImmutableSetMultimap.builder();
+    public static final Multimap<String, Property<?>> PROPERTIES;
+
+    public static final BooleanProperty ATTACHED = bool("attached");
+    public static final BooleanProperty BOTTOM = bool("bottom");
+    public static final BooleanProperty CONDITIONAL = bool("conditional");
+    public static final BooleanProperty DISARMED = bool("disarmed");
+    public static final BooleanProperty DRAG = bool("drag");
+    public static final BooleanProperty ENABLED = bool("enabled");
+    public static final BooleanProperty EXTENDED = bool("extended");
+    public static final BooleanProperty EYE = bool("eye");
+    public static final BooleanProperty FALLING = bool("falling");
+    public static final BooleanProperty HANGING = bool("hanging");
+    public static final BooleanProperty HAS_BOTTLE_0 = bool("has_bottle_0");
+    public static final BooleanProperty HAS_BOTTLE_1 = bool("has_bottle_1");
+    public static final BooleanProperty HAS_BOTTLE_2 = bool("has_bottle_2");
+    public static final BooleanProperty HAS_RECORD = bool("has_record");
+    public static final BooleanProperty HAS_BOOK = bool("has_book");
+    public static final BooleanProperty INVERTED = bool("inverted");
+    public static final BooleanProperty IN_WALL = bool("in_wall");
+    public static final BooleanProperty LIT = bool("lit");
+    public static final BooleanProperty LOCKED = bool("locked");
+    public static final BooleanProperty OCCUPIED = bool("occupied");
+    public static final BooleanProperty OPEN = bool("open");
+    public static final BooleanProperty PERSISTENT = bool("persistent");
+    public static final BooleanProperty POWERED = bool("powered");
+    public static final BooleanProperty SHORT = bool("short");
+    public static final BooleanProperty SIGNAL_FIRE = bool("signal_fire");
+    public static final BooleanProperty SNOWY = bool("snowy");
+    public static final BooleanProperty TRIGGERED = bool("triggered");
+    public static final BooleanProperty UNSTABLE = bool("unstable");
+    public static final BooleanProperty WATERLOGGED = bool("waterlogged");
+    public static final BooleanProperty VINE_END = bool("vine_end");
+    public static final BooleanProperty BERRIES = bool("berries");
+    public static final BooleanProperty UP = bool("up");
+    public static final BooleanProperty DOWN = bool("down");
+    public static final BooleanProperty NORTH = bool("north");
+    public static final BooleanProperty EAST = bool("east");
+    public static final BooleanProperty SOUTH = bool("south");
+    public static final BooleanProperty WEST = bool("west");
+
+    public static final IntegerProperty AGE_1 = integer("age", 0, 1);
+    public static final IntegerProperty AGE_2 = integer("age", 0, 2);
+    public static final IntegerProperty AGE_3 = integer("age", 0, 3);
+    public static final IntegerProperty AGE_5 = integer("age", 0, 5);
+    public static final IntegerProperty AGE_7 = integer("age", 0, 7);
+    public static final IntegerProperty AGE_15 = integer("age", 0, 15);
+    public static final IntegerProperty AGE_25 = integer("age", 0, 25);
+    public static final IntegerProperty BITES = integer("bites", 0, 6);
+    public static final IntegerProperty CANDLES = integer("candles", 1, 4);
+    public static final IntegerProperty DELAY = integer("delay", 1, 4);
+    public static final IntegerProperty DISTANCE = integer("distance", 1, 7);
+    public static final IntegerProperty EGGS = integer("eggs", 1, 4);
+    public static final IntegerProperty HATCH = integer("hatch", 0, 2);
+    public static final IntegerProperty LAYERS = integer("layers", 1, 8);
+    public static final IntegerProperty LEVEL_CAULDRON = integer("level", 1, 3);
+    public static final IntegerProperty LEVEL_COMPOSTER = integer("level", 0, 8);
+    public static final IntegerProperty LEVEL_FLOWING = integer("level", 1, 8);
+    public static final IntegerProperty LEVEL_HONEY = integer("honey_level", 0, 5);
+    public static final IntegerProperty LEVEL = integer("level", 0, 15);
+    public static final IntegerProperty MOISTURE = integer("moisture", 0, 7);
+    public static final NoteProperty NOTE = new NoteProperty("note"); // is stored as int, but represented as object
+    public static final IntegerProperty PICKLES = integer("pickles", 1, 4);
+    public static final IntegerProperty POWER = integer("power", 0, 15);
+    public static final IntegerProperty STAGE = integer("stage", 0, 1);
+    public static final IntegerProperty STABILITY_DISTANCE = integer("distance", 0, 7);
+    public static final IntegerProperty RESPAWN_ANCHOR_CHARGES = integer("charges", 0, 4);
+    public static final RotationProperty ROTATION_16 = new RotationProperty("rotation"); // is stored as int, but represented as enum
+
+    public static final EnumProperty<Axis> HORIZONTAL_AXIS = enumeration("axis", Axis.class, Axis.X, Axis.Z);
+    public static final EnumProperty<Axis> AXIS = enumeration("axis", Axis.class);
+    public static final EnumProperty<BlockFace> FACING = enumeration("facing", BlockFace.class, BlockFace::isCartesian);
+    public static final EnumProperty<BlockFace> FACING_HOPPER = enumeration("facing", BlockFace.class, ((Predicate<BlockFace>) BlockFace::isCartesian).and(face -> face != BlockFace.UP));
+    public static final EnumProperty<BlockFace> HORIZONTAL_FACING = enumeration("facing", BlockFace.class, BlockFace::isCardinal);
+    public static final EnumProperty<Jigsaw.Orientation> ORIENTATION = enumeration("orientation", Jigsaw.Orientation.class);
+    public static final EnumProperty<FaceAttachable.AttachedFace> ATTACH_FACE = enumeration("face", FaceAttachable.AttachedFace.class);
+    public static final EnumProperty<Bell.Attachment> BELL_ATTACHMENT = enumeration("attachment", Bell.Attachment.class);
+    public static final EnumProperty<Wall.Height> EAST_WALL = enumeration("east", Wall.Height.class);
+    public static final EnumProperty<Wall.Height> NORTH_WALL = enumeration("north", Wall.Height.class);
+    public static final EnumProperty<Wall.Height> SOUTH_WALL = enumeration("south", Wall.Height.class);
+    public static final EnumProperty<Wall.Height> WEST_WALL = enumeration("west", Wall.Height.class);
+    public static final EnumProperty<RedstoneWire.Connection> EAST_REDSTONE = enumeration("east", RedstoneWire.Connection.class);
+    public static final EnumProperty<RedstoneWire.Connection> NORTH_REDSTONE = enumeration("north", RedstoneWire.Connection.class);
+    public static final EnumProperty<RedstoneWire.Connection> SOUTH_REDSTONE = enumeration("south", RedstoneWire.Connection.class);
+    public static final EnumProperty<RedstoneWire.Connection> WEST_REDSTONE = enumeration("west", RedstoneWire.Connection.class);
+    public static final EnumProperty<Bisected.Half> DOUBLE_BLOCK_HALF = enumeration("half", Bisected.Half.class);
+    public static final EnumProperty<Bisected.Half> HALF = enumeration("half", Bisected.Half.class);
+    public static final EnumProperty<Rail.Shape> RAIL_SHAPE = enumeration("shape", Rail.Shape.class);
+    public static final EnumProperty<Rail.Shape> RAIL_SHAPE_STRAIGHT = enumeration("shape", Rail.Shape.class, Rail.Shape::isStraight);
+    public static final EnumProperty<Bed.Part> BED_PART = enumeration("part", Bed.Part.class);
+    public static final EnumProperty<Chest.Type> CHEST_TYPE = enumeration("type", Chest.Type.class);
+    public static final EnumProperty<Comparator.Mode> MODE_COMPARATOR = enumeration("mode", Comparator.Mode.class);
+    public static final EnumProperty<Door.Hinge> DOOR_HINGE = enumeration("hinge", Door.Hinge.class);
+    public static final EnumProperty<Instrument> NOTEBLOCK_INSTRUMENT = enumeration("instrument", Instrument.class);
+    public static final EnumProperty<TechnicalPiston.Type> PISTON_TYPE = enumeration("type", TechnicalPiston.Type.class);
+    public static final EnumProperty<Slab.Type> SLAB_TYPE = enumeration("type", Slab.Type.class);
+    public static final EnumProperty<Stairs.Shape> STAIRS_SHAPE = enumeration("shape", Stairs.Shape.class);
+    public static final EnumProperty<StructureBlock.Mode> STRUCTUREBLOCK_MODE = enumeration("mode", StructureBlock.Mode.class);
+    public static final EnumProperty<Bamboo.Leaves> BAMBOO_LEAVES = enumeration("leaves", Bamboo.Leaves.class);
+    public static final EnumProperty<BigDripleaf.Tilt> TILT = enumeration("tilt", BigDripleaf.Tilt.class);
+    public static final EnumProperty<BlockFace> VERTICAL_DIRECTION = enumeration("vertical_direction", BlockFace.class, face -> Math.abs(face.getModY()) > 0);
+    public static final EnumProperty<PointedDripstone.Thickness> DRIPSTONE_THICKNESS = enumeration("thickness", PointedDripstone.Thickness.class);
+    public static final EnumProperty<SculkSensor.Phase> SCULK_SENSOR_PHASE = enumeration("sculk_sensor_phase", SculkSensor.Phase.class);
+
+    // Must go after creation of all properties
+    static {
+        PROPERTIES = PROPERTY_MULTIMAP_BUILDER.build();
+    }
+
+    private final String name;
+    private final Class<T> type;
+
+    protected Property(@NotNull String name, @NotNull Class<T> type) {
+        this.name = name;
+        this.type = type;
+        PROPERTY_MULTIMAP_BUILDER.put(name, this);
+    }
+
+    /**
+     * Gets the name of this property.
+     *
+     * @return the name
+     */
+    public @NotNull String name() {
+        return name;
+    }
+
+    /**
+     * Gets the value type of this property.
+     *
+     * @return the value type
+     */
+    public @NotNull Class<T> type() {
+        return type;
+    }
+
+    /**
+     * Gets the string name for a value of this property.
+     *
+     * @param value the value to get the string name of
+     * @return the string name of the value
+     * @throws IllegalArgumentException if the value is not valid for
+     * @see #value(String)
+     */
+    public abstract @NotNull String name(@NotNull T value);
+
+    /**
+     * Checks if the name is a valid name
+     * for a value of this property.
+     *
+     * @param name the name to check
+     * @return true if valid
+     * @see #value(String)
+     */
+    public abstract boolean isValidName(@NotNull String name);
+
+    /**
+     * Gets the value of this property from the string name.
+     * Throws an exception if no value is found with that name.
+     *
+     * @param name the name of the value
+     * @return the property with the specified name
+     * @see #isValidName(String)
+     */
+    public abstract @NotNull T value(@NotNull String name);
+
+    /**
+     * Checks if the object is a valid value for this property.
+     *
+     * @param object the object to check
+     * @return true if its a valid value
+     * @see #setValue(PropertiesHolder, Object)
+     */
+    public abstract boolean isValue(@NotNull Object object);
+
+    /**
+     * Gets an immutable collection of possible values for this property.
+     *
+     * @return an immutable collection of values
+     */
+    public abstract @NotNull Collection<@NotNull T> values();
+
+    /**
+     * Checks if a {@link PropertiesHolder} has this property.
+     *
+     * @param holder the holder of a set of properties (like {@link org.bukkit.block.data.BlockData})
+     * @return true if this property is present
+     * @see PropertiesHolder#hasProperty(Property)
+     */
+    public boolean hasValueOn(@NotNull PropertiesHolder holder) {
+        return holder.hasProperty(this);
+    }
+
+    /**
+     * Gets the value from a {@link PropertiesHolder} for this property.
+     *
+     * @param holder the holder of a set of properties (like {@link org.bukkit.block.data.BlockData})
+     * @return the non-null value
+     * @throws IllegalArgumentException if this property is not present
+     * @see #hasValueOn(PropertiesHolder)
+     * @see PropertiesHolder#getValue(Property)
+     */
+    public @NotNull T getValue(@NotNull PropertiesHolder holder) {
+        return holder.getValue(this);
+    }
+
+    /**
+     * Gets the optional of the value for this property.
+     *
+     * @param holder the holder of a set of properties (like {@link org.bukkit.block.data.BlockData})
+     * @return the optional of the value, will be empty if the property is not present
+     * @see #getValue(PropertiesHolder)
+     * @see PropertiesHolder#getOptionalValue(Property)
+     */
+    public @NotNull Optional<T> getOptionalValue(@NotNull PropertiesHolder holder) {
+        return holder.getOptionalValue(this);
+    }
+
+    /**
+     * Sets the value on a {@link PropertiesHolder} for this property.
+     *
+     * @param holder the holder of a set of properties (like {@link org.bukkit.block.data.BlockData})
+     * @param value the value for this property
+     * @throws IllegalArgumentException if this property is not present
+     * @see #hasValueOn(PropertiesHolder)
+     * @see PropertiesHolder#hasProperty(Property)
+     */
+    public void setValue(@NotNull PropertiesHolder holder, @NotNull T value) {
+        holder.setValue(this, value);
+    }
+
+    /**
+     * Sets the value on a {@link PropertiesHolder} for this property.
+     *
+     * @param holder the holder of a set of properties (like {@link org.bukkit.block.data.BlockData})
+     * @param value the value for this property
+     * @throws IllegalArgumentException if this property is not present
+     * @see #hasValueOn(PropertiesHolder)
+     * @see PropertiesHolder#hasProperty(Property)
+     */
+    @SuppressWarnings("unchecked")
+    public void setValue(@NotNull PropertiesHolder holder, @NotNull Object value) {
+        if (!this.isValue(value)) {
+            throw EXCEPTION_CREATOR.create(value, ExceptionCreator.Type.VALUE, this);
+        }
+        this.setValue(holder, (T) value);
+    }
+
+    @Override
+    public String toString() {
+        return MoreObjects.toStringHelper(this)
+            .add("name", this.name)
+            .add("type", this.type)
+            .add("values", this.values())
+            .toString();
+    }
+
+    private static IntegerProperty integer(String name, int min, int max) {
+        return new IntegerProperty(name, min, max);
+    }
+
+    private static BooleanProperty bool(String name) {
+        return new BooleanProperty(name);
+    }
+
+    private static <E extends Enum<E>> EnumProperty<E> enumeration(String name, Class<E> enumClass) {
+        return new EnumProperty<>(name, enumClass, Set.of(enumClass.getEnumConstants()));
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    @SafeVarargs
+    private static <E extends Enum<E>> EnumProperty<E> enumeration(String name, Class<E> enumClass, E...values) {
+        return new EnumProperty<>(name, enumClass, Set.of(values));
+    }
+
+    private static <E extends Enum<E>> EnumProperty<E> enumeration(String name, Class<E> enumClass, Predicate<E> test) {
+        return new EnumProperty<>(name, enumClass, Arrays.stream(enumClass.getEnumConstants()).filter(test).collect(Collectors.toSet()));
+    }
+
+    @FunctionalInterface
+    interface ExceptionCreator {
+
+        @NotNull IllegalArgumentException create(@NotNull Object value, @NotNull Type type, @NotNull Property<?> property);
+
+        enum Type {
+            NAME,
+            VALUE;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/world/data/RotationProperty.java b/src/main/java/io/papermc/paper/world/data/RotationProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb16c2f79fa2aeb8ff09dc6d805b5f5a60d59377
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/data/RotationProperty.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.world.data;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import org.bukkit.block.BlockFace;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Special exception for the {@link Property#ROTATION_16} property because
+ * in the API it's represented as an enum, but stored as an integer.
+ */
+public final class RotationProperty extends EnumProperty.EnumIntRepresented<BlockFace> {
+
+    private static final Set<BlockFace> VALUES;
+    static {
+        final Set<BlockFace> values = new LinkedHashSet<>();
+        for (BlockFace face : BlockFace.values()) {
+            if (face.getModY() == 0 && (face.getModZ() != 0 || face.getModX() != 0)) {
+                values.add(face);
+            }
+        }
+        Preconditions.checkArgument(values.size() == 16, "Expected 16 enum values");
+        VALUES = Sets.immutableEnumSet(values);
+    }
+
+    RotationProperty(String name) {
+        super(name, BlockFace.class, VALUES, RotationProperty::enumToInt);
+    }
+
+    private static int enumToInt(BlockFace rotation) {
+        return switch (rotation) {
+            case SOUTH -> 0x0;
+            case SOUTH_SOUTH_WEST -> 0x1;
+            case SOUTH_WEST -> 0x2;
+            case WEST_SOUTH_WEST -> 0x3;
+            case WEST -> 0x4;
+            case WEST_NORTH_WEST -> 0x5;
+            case NORTH_WEST -> 0x6;
+            case NORTH_NORTH_WEST -> 0x7;
+            case NORTH -> 0x8;
+            case NORTH_NORTH_EAST -> 0x9;
+            case NORTH_EAST -> 0xA;
+            case EAST_NORTH_EAST -> 0xB;
+            case EAST -> 0xC;
+            case EAST_SOUTH_EAST -> 0xD;
+            case SOUTH_EAST -> 0xE;
+            case SOUTH_SOUTH_EAST -> 0xF;
+            default -> throw new IllegalArgumentException("Illegal rotation " + rotation);
+        };
+    }
+}
diff --git a/src/main/java/org/bukkit/Note.java b/src/main/java/org/bukkit/Note.java
index fc3da7ce6f7948aeab0962d9472e8f3a126834cf..7b772d0842885b914860a6cf54aed0907825ace9 100644
--- a/src/main/java/org/bukkit/Note.java
+++ b/src/main/java/org/bukkit/Note.java
@@ -9,7 +9,14 @@ import org.jetbrains.annotations.Nullable;
 /**
  * A note class to store a specific note.
  */
-public class Note {
+// Paper start - implement Comparable
+public class Note implements Comparable<Note> {
+
+    @Override
+    public int compareTo(@NotNull Note other) {
+        return Byte.compare(this.note, other.note);
+    }
+    // Paper end
 
     /**
      * An enum holding tones.
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index 88acc4d2bd56748630840dc9f1c2cb253711eb38..1ba56d26f78e065d49ee63cd3af3415632909dd4 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -269,5 +269,15 @@ public interface UnsafeValues {
      * @throws IllegalStateException if no biome by the given key is registered.
      */
     void setBiomeKey(RegionAccessor accessor, int x, int y, int z, NamespacedKey biomeKey);
+
+    /**
+     * Gets the string representation for this bukkit enum.
+     *
+     * @param enumProperty the enum data property
+     * @param bukkitEnum the enum to get the string representation of
+     * @param <B> the bukkit enum type
+     * @return the string representation of the supplied enum
+     */
+    <B extends Enum<B>> @org.jetbrains.annotations.NotNull String getPropertyEnumName(@org.jetbrains.annotations.NotNull io.papermc.paper.world.data.EnumProperty<B> enumProperty, @org.jetbrains.annotations.NotNull B bukkitEnum);
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/block/BlockFace.java b/src/main/java/org/bukkit/block/BlockFace.java
index fe83ed9bf6b6288991b044bb992bd8b2f00edc24..d476385fcb0a1c62d85cb69398b01998d5734644 100644
--- a/src/main/java/org/bukkit/block/BlockFace.java
+++ b/src/main/java/org/bukkit/block/BlockFace.java
@@ -104,6 +104,15 @@ public enum BlockFace {
         }
     }
 
+    // Paper start
+    public boolean isCardinal() {
+        return switch (this) {
+            case NORTH, SOUTH, EAST, WEST -> true;
+            default -> false;
+        };
+    }
+    // Paper end
+
     @NotNull
     public BlockFace getOppositeFace() {
         switch (this) {
diff --git a/src/main/java/org/bukkit/block/data/BlockData.java b/src/main/java/org/bukkit/block/data/BlockData.java
index b166d053b3c44f06cb1f5b643e7f7e117eb21d17..9c732874860c7c469f883be9a52eb190753705b9 100644
--- a/src/main/java/org/bukkit/block/data/BlockData.java
+++ b/src/main/java/org/bukkit/block/data/BlockData.java
@@ -10,7 +10,7 @@ import org.bukkit.block.BlockSupport;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public interface BlockData extends Cloneable {
+public interface BlockData extends Cloneable, io.papermc.paper.world.data.PropertiesHolder { // Paper - property API
 
     /**
      * Get the Material represented by this block data.
diff --git a/src/main/java/org/bukkit/block/data/Rail.java b/src/main/java/org/bukkit/block/data/Rail.java
index c8bdab081a316a9fd227d78a70c43c502e4085ef..027ebe6d015b52a112dba353e20f0ca563c7f537 100644
--- a/src/main/java/org/bukkit/block/data/Rail.java
+++ b/src/main/java/org/bukkit/block/data/Rail.java
@@ -83,5 +83,10 @@ public interface Rail extends Waterlogged {
          * block.
          */
         NORTH_EAST;
+        // Paper start
+        public boolean isStraight() {
+            return this != SOUTH_EAST && this != SOUTH_WEST && this != NORTH_WEST && this != NORTH_EAST;
+        }
+        // Paper end
     }
 }
